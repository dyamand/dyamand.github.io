## Schema aggregation

!!! success "_e.0.0_ If there are no schema online, the GraphQL aggregator should return the base schema"
!!! failure "_e.0.1_ For each conflicting GraphQL conflicting schema provider, the GraphQL aggregator should throw an IllegalStateException"
!!! success "_e.0.2_ For every GraphQL schema provider that comes online and goes offline again the schema of the GraphQL aggregator should be empty"
!!! warning "_e.0.3.b_ If two GraphQL schema providers are put online, each with 1 mutation which are not the same, the 2 mutations should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.c_ If two GraphQL schema providers are put online, each with 1 subscription which are not the same, the 2 subscriptions should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.d_ If two GraphQL schema providers are put online, each with 1 type which are not the same, the 2 types should exist in the schema generated by the GraphQL aggregator"

## Queries

!!! success "_e.1.0_ If there are no schemas added to the GraphQL aggregator, all queries should be answered with an error"
!!! success "_e.1.1_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, all queries should be available in the aggregated schema"
!!! success "_e.1.2_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, every query adherent to the aggregated schema should succeed"

## Types

!!! success "_e.2.0_ If there are no schemas added to the GraphQL aggregator, no types other than the Query type should be available in the aggregated schema"
!!! success "_e.2.1_ If N GraphQL schema providers come online, each with M types that are different across all schemas, all types should be available in the aggregated schema"

## Scalars

!!! success "_c.3.0_ If N schemas each define M scalars, they should all be present in the aggregated schema"

## Mutations

!!! success "_e.4.0_ If there are no schema in the GraphQL aggregator, all mutations should be answered with an error"
!!! success "_e.4.1_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, all mutations should be available in the aggregated schema"
!!! success "_e.4.2_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, every mutation adherent to the aggregated schema should succeed"

## Subscriptions

In order to support subscriptions in a scalable way, the communication with the clients and the actual subscriptions are split. The Subscriptions endpoint is responsible to setup an SSE connection with the clients interested in receiving event updates. The DYAMAND GraphQL endpoint can be used by clients to indicate which updates should be sent.

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embeddedchart/46e35fec-f7ba-43b4-975b-b5c720818391" id="SMUMrJcWB6p4"></iframe></div>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embeddedchart/2c5b2b2c-40e1-4f73-a99b-9a357be790c3" id="Jj7Qd2R5XbAs"></iframe></div>

!!! failure "_e.5.0_ If there are no schema in the GraphQL aggregator, all subscriptions should be answered with an error"
!!! failure "_e.5.1_ If a GraphQL service with a random schema is online, every subscription adherent to that schema should succeed"
!!! failure "_e.5.2_ If a GraphQL service is online and has a client subscribed to, if the service sends an event, the event should reach the client"

### Stream endpoint

!!! success "_e.6.0_ When N clients all set up a stream, N different stream IDs should be returned and those stream IDs should be in the key value store"
!!! success "_e.6.0.E.1_ When N clients all request a stream ID but do not set up an SSE connection, the stream IDs should not be in the key value store anymore after the configured timeout"
!!! success "_e.6.0.E.2_ When a client tries to set up an SSE connection without creating a stream ID, a 404 should be returned"
!!! success "_e.6.0.E.3_ When a client tries to set up an SSE connection after an SSE connection for that stream ID has already been created, a 410 should be returned"
!!! success "_e.6.0.E.4_ When a client tries to set up an SSE connection but includes an Accept header different from text/event-stream, a 406 should be returned"
!!! success "_e.6.1_ When a client sets up a stream and closes the connection, the stream ID should no longer be available and an event should have been sent on the *graphql.streamRemoved* topic containing the stream ID"
!!! success "_e.6.2_ When N clients set up a stream and the streams endpoint stops, no stream IDs should be available and an event should have been sent on the *graphql.streamRemoved* topic for all stream IDs"
!!! success "_e.6.3_ When N stream endpoints are available, all using the same key value store and pubsub, starting M clients distributed over the different endpoints should result in M different stream IDs"
!!! success "_e.6.4_ When a client sets up an SSE connection and a random message is sent on the pubsub on topic _streamId_/_eventType_, an event should be sent on the SSE connection with event == eventType and data equal to the content of the message sent on the pubsub"
!!! success "_e.6.5_ When a client sets up an SSE connection and a random message is sent on the pubsub on topic _otherStreamId_/_eventType_, no event should be received over the SSE connection"
!!! success "_e.6.6_ When a client sets up an SSE connection and no messages are sent on the pubsub, there should be keep-alive message every keep-alive interval"

### GraphQL endpoint

!!! success "_e.7.0_ When a client executes a subscription with a valid stream ID and an event arrives, a message should be sent with topic _streamId_/_operationName_ and the message should be equal to the output generated by the GraphQL subscription"
!!! success "_e.7.0.E.1_ When a client executes a subscription without a stream ID, the subscription should fail with a 400 status code"
!!! success "_e.7.0.E.2_ When a client executes a subscription with a stream ID and the stream ID is not registered, the subscription should fail with a 400 status code"
!!! success "_e.7.1_ When a client executes a subscription with a valid stream ID, cancels it, and an event arrives, there should be no message on topic _streamId_/_operationName_"
!!! failure "_e.7.2_ When a client executes a subscription with a valid stream ID and an event is received on the *graphql.streamRemoved* topic, all created subscriptions should be cancelled and as such, no new data on the publisher should trigger an event on the pubsub"

```
# Query.
extend type Query {
	systemInfo: SystemInfo!
}

# System info
type SystemInfo {
	# Bundles.
	bundles: [Bundle!]!
	# Start time.
	startTime: Timestamp!
	# Uptime.
	uptime: Timestamp!
}

# Bundle.
type Bundle {
	# Symbolic Name.
	symbolicName: String!
	# Version
	version: Version!
}

# Version.
type Version {
	# Full version.
	full: String!
	# Major version.
	major: Int!
	# Minor version.
	minor: Int!
	# Patch version.
	micro: Int!
	# Qualifier.
	qualifier: String!
}

# Status an entity can be in.
enum Status {
	# The entity is online.
	ONLINE
	# The entity has announced that it was going offline.
	OFFLINE
	# We lost communication with the entity.
	LOST_COMMUNICATION
}

# Indicates the health of an entity.
type Health {
	# Number of health checks that think everything is fine.
	healthy: Int!
	# Number of health checks that indicated a warning.
	warning: Int!
	# Number of health checks that indicated an error.
	error: Int!
	# Number of health checks that failed.
	failed: Int!
	# Health checks.
	checks: [HealthCheck!]!
}

# Possible health statuses.
enum HealthStatus {
	# Everything is OK.
	HEALTHY
	# The health check succeeded and indicated the situation to be a warning.
	WARNING
	# The health check succeeded and indicated the situation to be an error.
	ERROR
	# The health check failed.
	FAILED
}

# A health check is an indication of the status of a part of the system. The combination of the result of all health checks together indicates the actual health of the installation.
type HealthCheck {
	# Unique ID of the health check.
	id: String!
	# Description of the health check. Describes what aspect the health check actually checks.
	description: String!
	# Category of the health check. Categories can be used to group different health checks.
	category: String!
	# Current status of the health check.
	status: HealthStatus!
	# Message explaining the current status of the health check.
	message: String!
}

# Includes all the possible names for an installation
type Names {
	# Names that uniquely identify this installation
	unique: [String!]!
	# Friendly names generated by the installation itself
	machine: [String!]!
	# Friendly names assigned to this installation by the user
	user: [String!]!
}

# Discovery protocol
type DiscoveryProtocol {
	# id of the protocol
	id: ID!
	# symbolic name of the plugin that registered the protocol
	pluginName: String!
	# version of the plugin that registered the protocol
	pluginVersion: Version!
}

# Unix epoch in seconds.
scalar Timestamp
```
