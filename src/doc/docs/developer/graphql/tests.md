## Schema aggregation

!!! success "_e.0.0_ If there are no schema online, the GraphQL aggregator should return the base schema"
!!! failure "_e.0.1_ For each conflicting GraphQL conflicting schema provider, the GraphQL aggregator should throw an IllegalStateException"
!!! success "_e.0.2_ For every GraphQL schema provider that comes online and goes offline again the schema of the GraphQL aggregator should be empty"
!!! warning "_e.0.3.b_ If two GraphQL schema providers are put online, each with 1 mutation which are not the same, the 2 mutations should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.c_ If two GraphQL schema providers are put online, each with 1 subscription which are not the same, the 2 subscriptions should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.d_ If two GraphQL schema providers are put online, each with 1 type which are not the same, the 2 types should exist in the schema generated by the GraphQL aggregator"

## Queries

!!! success "_e.1.0_ If there are no schemas added to the GraphQL aggregator, all queries should be answered with an error"
!!! success "_e.1.1_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, all queries should be available in the aggregated schema"
!!! success "_e.1.2_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, every query adherent to the aggregated schema should succeed"

## Types

!!! success "_e.2.0_ If there are no schemas added to the GraphQL aggregator, no types other than the Query type should be available in the aggregated schema"
!!! success "_e.2.1_ If N GraphQL schema providers come online, each with M types that are different across all schemas, all types should be available in the aggregated schema"

## Scalars

!!! success "_c.3.0_ If N schemas each define M scalars, they should all be present in the aggregated schema"

## Mutations

!!! success "_e.4.0_ If there are no schema in the GraphQL aggregator, all mutations should be answered with an error"
!!! success "_e.4.1_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, all mutations should be available in the aggregated schema"
!!! success "_e.4.2_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, every mutation adherent to the aggregated schema should succeed"

## Subscriptions

In order to support subscriptions in a scalable way, the communication with the clients and the actual subscriptions are split. The Subscriptions endpoint is responsible to setup an SSE connection with the clients interested in receiving event updates. The DYAMAND GraphQL endpoint can be used by clients to indicate which updates should be sent.

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embeddedchart/46e35fec-f7ba-43b4-975b-b5c720818391" id="SMUMrJcWB6p4"></iframe></div>

<div style="width: 640px; height: 480px; margin: 10px; position: relative;"><iframe allowfullscreen frameborder="0" style="width:640px; height:480px" src="https://lucid.app/documents/embeddedchart/2c5b2b2c-40e1-4f73-a99b-9a357be790c3" id="Jj7Qd2R5XbAs"></iframe></div>

!!! failure "_e.5.0_ If there are no schema in the GraphQL aggregator, all subscriptions should be answered with an error"
!!! failure "_e.5.1_ If a GraphQL service with a random schema is online, every subscription adherent to that schema should succeed"
!!! failure "_e.5.2_ If a GraphQL service is online and has a client subscribed to, if the service sends an event, the event should reach the client"

### Subscriptions endpoint

!!! success "_e.6.0_ When N clients all set up a subscription, N different subscription IDs should be returned and those subscription IDs should be in the key value store"
!!! success "_e.6.0.E.1_ When N clients all request a subscription ID but do not set up an SSE connection, the subscription IDs should not be in the key value store anymore after the configured timeout"
!!! success "_e.6.0.E.2_ When a client tries to set up an SSE connection without creating a subscription ID, a 404 should be returned"
!!! success "_e.6.1_ When a client sets up a subscription and closes the connection, the subscription ID should no longer be available and an event should have been sent on the *graphql.subscriptionRemoved* topic containing the subscription ID"
!!! success "_e.6.2_ When N clients set up a subscription and the subscription endpoint stops, no subscription IDs should be available and an event should have been sent on the *graphql.subscriptionRemoved* topic for all subscription IDs"
!!! success "_e.6.3_ When N subscription endpoints are available, all using the same key value store and pubsub, starting M clients distributed over the different endpoints should result in M different IDs"
!!! success "_e.6.4_ When a client sets up an SSE connection and a random message is sent on the pubsub on topic _subscriptionId_/_eventType_, an event should be sent on the SSE connection with event == eventType and data equal to the content of the message sent on the pubsub"
!!! success "_e.6.5_ When a client sets up an SSE connection and a random message is sent on the pubsub on topic _otherSubscriptionId_/_eventType_, no event should be received over the SSE connection"
!!! failure "_e.6.6_ When a client sets up an SSE connection and no messages are sent on the pubsub, there should be keep-alive message every keep-alive interval"

### GraphQL endpoint

!!! failure "_e.7.0_ When a client executes a subscription without a subscription ID, the subscription should fail with a 400 status code"
!!! failure "_e.7.1_ When a client executes a subscription with a subscriptionID and the subscription ID is not registered, the subscription should fail with a 400 status code"
!!! failure "_e.7.2_ When a client executes a subscription with a valid subscription ID and an event arrives, a message should be sent with topic _subscriptionId_/_operationName_ and the message should be equal to the output generated by the GraphQL subscription"

## Concurrency tests for the GraphQL endpoint

!!! failure "_e.9.1_ If n different valid queries arrive, they all should be answered without any errors"
!!! failure "_e.9.2_ If the same request arrive n times at the same time, they should all be answered without any errors"

```
# Query.
extend type Query {
	systemInfo: SystemInfo!
}

# System info
type SystemInfo {
	# Bundles.
	bundles: [Bundle!]!
	# Start time.
	startTime: Timestamp!
	# Uptime.
	uptime: Timestamp!
}

# Bundle.
type Bundle {
	# Symbolic Name.
	symbolicName: String!
	# Version
	version: Version!
}

# Version.
type Version {
	# Full version.
	full: String!
	# Major version.
	major: Int!
	# Minor version.
	minor: Int!
	# Patch version.
	micro: Int!
	# Qualifier.
	qualifier: String!
}

# Status an entity can be in.
enum Status {
	# The entity is online.
	ONLINE
	# The entity has announced that it was going offline.
	OFFLINE
	# We lost communication with the entity.
	LOST_COMMUNICATION
}

# Indicates the health of an entity.
type Health {
	# Number of health checks that think everything is fine.
	healthy: Int!
	# Number of health checks that indicated a warning.
	warning: Int!
	# Number of health checks that indicated an error.
	error: Int!
	# Number of health checks that failed.
	failed: Int!
	# Health checks.
	checks: [HealthCheck!]!
}

# Possible health statuses.
enum HealthStatus {
	# Everything is OK.
	HEALTHY
	# The health check succeeded and indicated the situation to be a warning.
	WARNING
	# The health check succeeded and indicated the situation to be an error.
	ERROR
	# The health check failed.
	FAILED
}

# A health check is an indication of the status of a part of the system. The combination of the result of all health checks together indicates the actual health of the installation.
type HealthCheck {
	# Unique ID of the health check.
	id: String!
	# Description of the health check. Describes what aspect the health check actually checks.
	description: String!
	# Category of the health check. Categories can be used to group different health checks.
	category: String!
	# Current status of the health check.
	status: HealthStatus!
	# Message explaining the current status of the health check.
	message: String!
}

# Includes all the possible names for an installation
type Names {
	# Names that uniquely identify this installation
	unique: [String!]!
	# Friendly names generated by the installation itself
	machine: [String!]!
	# Friendly names assigned to this installation by the user
	user: [String!]!
}

# Discovery protocol
type DiscoveryProtocol {
	# id of the protocol
	id: ID!
	# symbolic name of the plugin that registered the protocol
	pluginName: String!
	# version of the plugin that registered the protocol
	pluginVersion: Version!
}

# Unix epoch in seconds.
scalar Timestamp
```
