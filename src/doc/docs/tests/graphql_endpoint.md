```
# Query.
extend type Query {
    systemInfo: SystemInfo!
}

# System info
type SystemInfo {
    # Bundles.
    bundles: [Bundle!]!
    # Start time.
    startTime: Timestamp!
    # Uptime.
    uptime: Timestamp!
}

# Bundle.
type Bundle {
    # Symbolic Name.
    symbolicName: String!
    # Version
    version: Version!
}

# Version.
type Version {
	# Full version.
	full: String!
    # Major version.
    major: Int!
    # Minor version.
    minor: Int!
    # Patch version.
    micro: Int!
    # Qualifier.
    qualifier: String!
}

# Status an entity can be in.
enum Status {
    # The entity is online.
    ONLINE
    # The entity has announced that it was going offline.
    OFFLINE
    # We lost communication with the entity.
    LOST_COMMUNICATION
}

# Indicates the health of an entity.
type Health {
    # Number of health checks that think everything is fine.
    healthy: Int!
    # Number of health checks that indicated a warning.
    warning: Int!
    # Number of health checks that indicated an error.
    error: Int!
    # Number of health checks that failed.
    failed: Int!
    # Health checks.
    checks: [HealthCheck!]!
}

# Possible health statuses.
enum HealthStatus {
    # Everything is OK.
    HEALTHY
    # The health check succeeded and indicated the situation to be a warning.
    WARNING
    # The health check succeeded and indicated the situation to be an error.
    ERROR
    # The health check failed.
    FAILED
}

# A health check is an indication of the status of a part of the system. The combination of the result of all health checks together indicates the actual health of the installation.
type HealthCheck {
    # Unique ID of the health check.
    id: String!
    # Description of the health check. Describes what aspect the health check actually checks.
    description: String!
    # Category of the health check. Categories can be used to group different health checks.
    category: String!
    # Current status of the health check.
    status: HealthStatus!
    # Message explaining the current status of the health check.
    message: String!
}

# Includes all the possible names for an installation
type Names {
    # Names that uniquely identify this installation
    unique: [String!]!
    # Friendly names generated by the installation itself
    machine: [String!]!
    # Friendly names assigned to this installation by the user
    user: [String!]!
}

# Unix epoch in seconds.
scalar Timestamp
```

## Schema aggregation

!!! success "_e.0.0_ If there are no schema online, the GraphQL aggregator should return the base schema"
!!! failure "_e.0.1_ For each conflicting GraphQL conflicting schema provider, the GraphQL aggregator should throw an IllegalStateException"
!!! success "_e.0.2_ For every GraphQL schema provider that comes online and goes offline again the schema of the GraphQL aggregator should be empty"
!!! warning "_e.0.3.b_ If two GraphQL schema providers are put online, each with 1 mutation which are not the same, the 2 mutations should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.c_ If two GraphQL schema providers are put online, each with 1 subscription which are not the same, the 2 subscriptions should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.d_ If two GraphQL schema providers are put online, each with 1 type which are not the same, the 2 types should exist in the schema generated by the GraphQL aggregator"

## Queries

!!! success "_e.1.0_ If there are no schemas added to the GraphQL aggregator, all queries should be answered with an error"
!!! success "_e.1.1_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, all queries should be available in the aggregated schema"
!!! success "_e.1.2_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, every query adherent to the aggregated schema should succeed"

## Types

!!! success "_e.2.0_ If there are no schemas added to the GraphQL aggregator, no types other than the Query type should be available in the aggregated schema"
!!! success "_e.2.1_ If N GraphQL schema providers come online, each with M types that are different across all schemas, all types should be available in the aggregated schema"

## Scalars

!!! success "_c.3.0_ If N schemas each define M scalars, they should all be present in the aggregated schema"

## Mutations

!!! success "_e.4.0_ If there are no schema in the GraphQL aggregator, all mutations should be answered with an error"
!!! success "_e.4.1_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, all mutations should be available in the aggregated schema"
!!! success "_e.4.2_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, every mutation adherent to the aggregated schema should succeed"

## Subscriptions

!!! failure "_e.5.0_ If there are no schema in the GraphQL aggregator, all subscriptions should be answered with an error"
!!! failure "_e.5.1_ If a GraphQL service with a random schema is online, every subscription adherent to that schema should succeed"
!!! failure "_e.5.2_ If a GraphQL service is online and has a client subscribed to, if the service sends an event, the event should reach the client"

## Concurrency tests for the GraphQL endpoint

!!! failure "_e.9.1_ If n different valid queries arrive, they all should be answered without any errors"
!!! failure "_e.9.2_ If the same request arrive n times at the same time, they should all be answered without any errors"
