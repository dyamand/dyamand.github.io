```
# Query.
extend type Query {
	systemInfo: SystemInfo!
}

# System info
type SystemInfo {
	# Bundles.
	bundles: [Bundle!]!
	# Start time.
	startTime: Timestamp!
	# Uptime.
	uptime: Timestamp!
}

# Bundle.
type Bundle {
	# Symbolic Name.
	symbolicName: String!
	# Version
	version: Version!
}

# Version.
type Version {
	# Full version.
	full: String!
	# Major version.
	major: Int!
	# Minor version.
	minor: Int!
	# Patch version.
	micro: Int!
	# Qualifier.
	qualifier: String!
}

# Status an entity can be in.
enum Status {
	# The entity is online.
	ONLINE
	# The entity has announced that it was going offline.
	OFFLINE
	# We lost communication with the entity.
	LOST_COMMUNICATION
}

# Indicates the health of an entity.
type Health {
	# Number of health checks that think everything is fine.
	healthy: Int!
	# Number of health checks that indicated a warning.
	warning: Int!
	# Number of health checks that indicated an error.
	error: Int!
	# Number of health checks that failed.
	failed: Int!
	# Health checks.
	checks: [HealthCheck!]!
}

# Possible health statuses.
enum HealthStatus {
	# Everything is OK.
	HEALTHY
	# The health check succeeded and indicated the situation to be a warning.
	WARNING
	# The health check succeeded and indicated the situation to be an error.
	ERROR
	# The health check failed.
	FAILED
}

# A health check is an indication of the status of a part of the system. The combination of the result of all health checks together indicates the actual health of the installation.
type HealthCheck {
	# Unique ID of the health check.
	id: String!
	# Description of the health check. Describes what aspect the health check actually checks.
	description: String!
	# Category of the health check. Categories can be used to group different health checks.
	category: String!
	# Current status of the health check.
	status: HealthStatus!
	# Message explaining the current status of the health check.
	message: String!
}

# Includes all the possible names for an installation
type Names {
	# Names that uniquely identify this installation
	unique: [String!]!
	# Friendly names generated by the installation itself
	machine: [String!]!
	# Friendly names assigned to this installation by the user
	user: [String!]!
}

# Discovery protocol
type DiscoveryProtocol {
	# id of the protocol
	id: ID!
	# symbolic name of the plugin that registered the protocol
	pluginName: String!
	# version of the plugin that registered the protocol
	pluginVersion: Version!
}

# Unix epoch in seconds.
scalar Timestamp
```

## Schema aggregation

!!! success "_e.0.0_ If there are no schema online, the GraphQL aggregator should return the base schema"
!!! failure "_e.0.1_ For each conflicting GraphQL conflicting schema provider, the GraphQL aggregator should throw an IllegalStateException"
!!! success "_e.0.2_ For every GraphQL schema provider that comes online and goes offline again the schema of the GraphQL aggregator should be empty"
!!! warning "_e.0.3.b_ If two GraphQL schema providers are put online, each with 1 mutation which are not the same, the 2 mutations should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.c_ If two GraphQL schema providers are put online, each with 1 subscription which are not the same, the 2 subscriptions should exist in the schema generated by the GraphQL aggregator"
!!! warning "_e.0.3.d_ If two GraphQL schema providers are put online, each with 1 type which are not the same, the 2 types should exist in the schema generated by the GraphQL aggregator"

## Queries

!!! success "_e.1.0_ If there are no schemas added to the GraphQL aggregator, all queries should be answered with an error"
!!! success "_e.1.1_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, all queries should be available in the aggregated schema"
!!! success "_e.1.2_ If N GraphQL schema providers come online, each with M queries that are different across all schemas, every query adherent to the aggregated schema should succeed"

## Types

!!! success "_e.2.0_ If there are no schemas added to the GraphQL aggregator, no types other than the Query type should be available in the aggregated schema"
!!! success "_e.2.1_ If N GraphQL schema providers come online, each with M types that are different across all schemas, all types should be available in the aggregated schema"

## Scalars

!!! success "_c.3.0_ If N schemas each define M scalars, they should all be present in the aggregated schema"

## Mutations

!!! success "_e.4.0_ If there are no schema in the GraphQL aggregator, all mutations should be answered with an error"
!!! success "_e.4.1_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, all mutations should be available in the aggregated schema"
!!! success "_e.4.2_ If N GraphQL schema providers come online, each with M mutations that are different across all schemas, every mutation adherent to the aggregated schema should succeed"

## Subscriptions

!!! failure "_e.5.0_ If there are no schema in the GraphQL aggregator, all subscriptions should be answered with an error"
!!! failure "_e.5.1_ If a GraphQL service with a random schema is online, every subscription adherent to that schema should succeed"
!!! failure "_e.5.2_ If a GraphQL service is online and has a client subscribed to, if the service sends an event, the event should reach the client"

## Concurrency tests for the GraphQL endpoint

!!! failure "_e.9.1_ If n different valid queries arrive, they all should be answered without any errors"
!!! failure "_e.9.2_ If the same request arrive n times at the same time, they should all be answered without any errors"
