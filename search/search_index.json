{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DYAMAND \u00b6 In the last decades, the world has made significant technological advances. When we talk about the use of digital technology, it all started with the introduction of the PC, making it possible for the general public to use computing power, that was previously reserved for big research centers, in the comfort of their own home. After the introduction of the Internet, people could get connected with each other to exchange information all around the world. Gradually this evolved into a world in which nearly every human being is continuously connected with the rest of the world using a device that is significantly smaller and more powerful than PCs originally were. A similar evolution has been happening in the world of devices. Traditionally referred to as IoT , it has a significant impact on multiple application domains, ranging from home automation over eHealth, industry 4.0 and many more to smart cities. What all of these application domains have in common is that they face similar problems when bringing new applications to the market. Integration of devices is complex since they not only differ in what they enable, the way an application needs to connect to each and every device is potentially different, how devices model the data they sent is diverse and how they can be controlled is yet another source of variation. This heterogeneity is a source of frustration for application developers and inhibits innovation. DYAMAND simplifies the world of connected devices to make the creation of new, innovative applications easier. Flexibility \u00b6 As discussed above, there are a lot of factors to take into account when developing an application that makes use of connected devices. To tackle these challenges, DYAMAND is completely plugin-based. If you want to create a plugin, please have a look at the documentation for plugin developers . Device types \u00b6 Devices can measure some aspect of the environment or control the environment around them in some way. If this sounds vague, it is. A simple example is a temperature sensor: a device that measures the temperature of the environment it is deployed in and that does not allow controlling anything. A light on the other hand can be switched on and off, can optionally be dimmed or can even change color. These simple examples show how DYAMAND looks at devices, devices have state that can or can not be changed. DYAMAND in and of itself is not aware of any of these types (temperature, color, etc.), this information is provided at runtime by so-called Type Plugins . Technologies \u00b6 Every application domain has a particular set of technologies that are dominant. Again, DYAMAND in and of itself is not aware of any technology out there, Technology Plugins help DYAMAND in understanding the ins and outs of every technology out there. A Technology Plugin is responsible for device discovery, extracting technology-specific data out of the device and implementing the mechanisms to control the device. Abstraction \u00b6 In previous sections, Type Plugins and Technology Plugins were introduced. However, these two types of plugins alone do not simplify interacting with devices. To achieve this, DYAMAND introduces Translation Plugins . Based on knowledge about the technology on the one hand and the generic type(s) it supports on the other hand, a Translation Plugin makes sure that the technology-specific data as extracted by a Technology Plugin can be translated to a generic concept provided by a Type Plugin . Applications \u00b6 Once again, DYAMAND is not directly aware of what it should do with the data it receives or what to control, applications are basically another type of plugins, surprisingly called Application Plugins . Another way to develop applications is to use the provided GraphQL API. If you want to create an application using the external GraphQL API, please have a look at the documentation for application developers . Coming soon! \u00b6 Based on the abstraction DYAMAND creates, a number of generic services can be offered. More information on this will be provided soon.","title":"What is DYAMAND?"},{"location":"#welcome-to-dyamand","text":"In the last decades, the world has made significant technological advances. When we talk about the use of digital technology, it all started with the introduction of the PC, making it possible for the general public to use computing power, that was previously reserved for big research centers, in the comfort of their own home. After the introduction of the Internet, people could get connected with each other to exchange information all around the world. Gradually this evolved into a world in which nearly every human being is continuously connected with the rest of the world using a device that is significantly smaller and more powerful than PCs originally were. A similar evolution has been happening in the world of devices. Traditionally referred to as IoT , it has a significant impact on multiple application domains, ranging from home automation over eHealth, industry 4.0 and many more to smart cities. What all of these application domains have in common is that they face similar problems when bringing new applications to the market. Integration of devices is complex since they not only differ in what they enable, the way an application needs to connect to each and every device is potentially different, how devices model the data they sent is diverse and how they can be controlled is yet another source of variation. This heterogeneity is a source of frustration for application developers and inhibits innovation. DYAMAND simplifies the world of connected devices to make the creation of new, innovative applications easier.","title":"Welcome to DYAMAND"},{"location":"#flexibility","text":"As discussed above, there are a lot of factors to take into account when developing an application that makes use of connected devices. To tackle these challenges, DYAMAND is completely plugin-based. If you want to create a plugin, please have a look at the documentation for plugin developers .","title":"Flexibility"},{"location":"#device-types","text":"Devices can measure some aspect of the environment or control the environment around them in some way. If this sounds vague, it is. A simple example is a temperature sensor: a device that measures the temperature of the environment it is deployed in and that does not allow controlling anything. A light on the other hand can be switched on and off, can optionally be dimmed or can even change color. These simple examples show how DYAMAND looks at devices, devices have state that can or can not be changed. DYAMAND in and of itself is not aware of any of these types (temperature, color, etc.), this information is provided at runtime by so-called Type Plugins .","title":"Device types"},{"location":"#technologies","text":"Every application domain has a particular set of technologies that are dominant. Again, DYAMAND in and of itself is not aware of any technology out there, Technology Plugins help DYAMAND in understanding the ins and outs of every technology out there. A Technology Plugin is responsible for device discovery, extracting technology-specific data out of the device and implementing the mechanisms to control the device.","title":"Technologies"},{"location":"#abstraction","text":"In previous sections, Type Plugins and Technology Plugins were introduced. However, these two types of plugins alone do not simplify interacting with devices. To achieve this, DYAMAND introduces Translation Plugins . Based on knowledge about the technology on the one hand and the generic type(s) it supports on the other hand, a Translation Plugin makes sure that the technology-specific data as extracted by a Technology Plugin can be translated to a generic concept provided by a Type Plugin .","title":"Abstraction"},{"location":"#applications","text":"Once again, DYAMAND is not directly aware of what it should do with the data it receives or what to control, applications are basically another type of plugins, surprisingly called Application Plugins . Another way to develop applications is to use the provided GraphQL API. If you want to create an application using the external GraphQL API, please have a look at the documentation for application developers .","title":"Applications"},{"location":"#coming-soon","text":"Based on the abstraction DYAMAND creates, a number of generic services can be offered. More information on this will be provided soon.","title":"Coming soon!"},{"location":"applicationdevelopers/","text":"Introduction to GraphQL Retrieve information Query Subscription Remote control","title":"For application developers"},{"location":"endusers/","text":"TODO Authentication Installing a dyamand client Monitoring Installations Devices health checks Management Technologies Configuration Control Applications","title":"For end users"},{"location":"plugindevelopers/","text":"Plugin developers should be aware of the concepts that form the basis of DYAMAND . All of these concepts should be mapped onto a technology-specific concept when implementing a technology in DYAMAND . Discovery & Description \u00b6 Before anything else can happen, a device should be discovered and their functionalities should be described. Discovery is the notification of the fact that a device is available or no longer available. Description is the act of describing the functionalities of the just discovered device. The discovery orchestration begins with a Technology Plugin detecting a new device using whatever mechanism the implemented technology supports. DYAMAND will ask all Translation Plugins whether or not they know how to translate the just discovered device to a more generic counterpart. This part of the orchestration allows Description to happen. Translation Plugins offer information about the just discovered device, e.g. a plugin can indicate that the just discovered device can measure temperature. Once DYAMAND has translated the initial technology-specific device, interested Application Plugins are notified of both the technology-specific device as well as its generic counterparts. State changes \u00b6 Once a device has been discovered, the Technology Plugin is responsible to monitor changes in the state of the device. After detecting the state change, DYAMAND will offer all interested Translation Plugins to translate the just altered state to its generic counterpart. In contrast to the translation in the previous section, this time the value of the state is actually translated. Control \u00b6 Changing the state of discovered devices is done using the Control orchestration. As opposed to the orchestrations discussed above, this one actually starts by the application deciding the state of a previously discovered device should be changed. DYAMAND will check whether all states can be applied by loaded Technology Plugins . If that is not the case, DYAMAND will allow Translation Plugins to translate the states that need to be applied (generic states) to more specific states that need to be applied. This process is repeated until all states have either been translated or no translations can be found anymore. Once the states that should be applied have been determined, by optionally translating them, those states are offered to the Technology Plugin to actually apply them. Coming soon! \u00b6 anatomy of a technology repository use cases simple targeted technology general-purpose technology","title":"Overview"},{"location":"plugindevelopers/#discovery-description","text":"Before anything else can happen, a device should be discovered and their functionalities should be described. Discovery is the notification of the fact that a device is available or no longer available. Description is the act of describing the functionalities of the just discovered device. The discovery orchestration begins with a Technology Plugin detecting a new device using whatever mechanism the implemented technology supports. DYAMAND will ask all Translation Plugins whether or not they know how to translate the just discovered device to a more generic counterpart. This part of the orchestration allows Description to happen. Translation Plugins offer information about the just discovered device, e.g. a plugin can indicate that the just discovered device can measure temperature. Once DYAMAND has translated the initial technology-specific device, interested Application Plugins are notified of both the technology-specific device as well as its generic counterparts.","title":"Discovery &amp; Description"},{"location":"plugindevelopers/#state-changes","text":"Once a device has been discovered, the Technology Plugin is responsible to monitor changes in the state of the device. After detecting the state change, DYAMAND will offer all interested Translation Plugins to translate the just altered state to its generic counterpart. In contrast to the translation in the previous section, this time the value of the state is actually translated.","title":"State changes"},{"location":"plugindevelopers/#control","text":"Changing the state of discovered devices is done using the Control orchestration. As opposed to the orchestrations discussed above, this one actually starts by the application deciding the state of a previously discovered device should be changed. DYAMAND will check whether all states can be applied by loaded Technology Plugins . If that is not the case, DYAMAND will allow Translation Plugins to translate the states that need to be applied (generic states) to more specific states that need to be applied. This process is repeated until all states have either been translated or no translations can be found anymore. Once the states that should be applied have been determined, by optionally translating them, those states are offered to the Technology Plugin to actually apply them.","title":"Control"},{"location":"plugindevelopers/#coming-soon","text":"anatomy of a technology repository use cases simple targeted technology general-purpose technology","title":"Coming soon!"},{"location":"applications/services/","text":"TODO","title":"Service lifecycle"},{"location":"dyamand/model/","text":"Interoperability between different technologies requires a common model to be used. DYAMAND uses a generic domain model that is flexible enough to model every technology. The world according to DYAMAND is a collection of devices modeled by org.dyamand.model.Device . These devices can contain any number of services (modeled by org.dyamand.model.service.Service ). Each service in its turn consists of any number of states that represent the capabilities of the service. To model these states, the objects defined by LwM2M are used as a basis. To see how this generic model can be extended for specific technologies or use cases, take a look at the documentation on plugins .","title":"Generic model"},{"location":"dyamand/plugins/","text":"Extending DYAMAND using plugins \u00b6 DYAMAND uses a plugin architecture to support different technologies, types of devices and interfaces. Four types of plugins can be identified, depending on what extra functionality they add to DYAMAND. Type plugins \u00b6 DYAMAND only knows about the generic model described here . New concepts are defined by so-called type plugins. These plugins allow any application domain to be modeled without having to change anything to the core DYAMAND framework. More information on how to add new types can be found here . Service Discovery Protocol plugins \u00b6 SDP plugins are responsible for the interaction with physical devices. They should be able to discover, get state changes from and control services. Whenever an SDP plugin discovers a new service, it is automatically added to a top-level service according to whichever address the new service was found on. More information on how to write an SDP plugin can be found here . Translation plugins \u00b6 Translation plugins are plugins that translate services discovered by SDP plugins into services or states that use generic types (independent of any device technology). Application plugins \u00b6 Application plugins are those plugins that use the functionality of any Service discovered by DYAMAND.","title":"Plugins"},{"location":"dyamand/plugins/#extending-dyamand-using-plugins","text":"DYAMAND uses a plugin architecture to support different technologies, types of devices and interfaces. Four types of plugins can be identified, depending on what extra functionality they add to DYAMAND.","title":"Extending DYAMAND using plugins"},{"location":"dyamand/plugins/#type-plugins","text":"DYAMAND only knows about the generic model described here . New concepts are defined by so-called type plugins. These plugins allow any application domain to be modeled without having to change anything to the core DYAMAND framework. More information on how to add new types can be found here .","title":"Type plugins"},{"location":"dyamand/plugins/#service-discovery-protocol-plugins","text":"SDP plugins are responsible for the interaction with physical devices. They should be able to discover, get state changes from and control services. Whenever an SDP plugin discovers a new service, it is automatically added to a top-level service according to whichever address the new service was found on. More information on how to write an SDP plugin can be found here .","title":"Service Discovery Protocol plugins"},{"location":"dyamand/plugins/#translation-plugins","text":"Translation plugins are plugins that translate services discovered by SDP plugins into services or states that use generic types (independent of any device technology).","title":"Translation plugins"},{"location":"dyamand/plugins/#application-plugins","text":"Application plugins are those plugins that use the functionality of any Service discovered by DYAMAND.","title":"Application plugins"},{"location":"plugins/control_with_translations/","text":"","title":"Control with translations"},{"location":"plugins/control_without_translations/","text":"","title":"Control without translations"},{"location":"plugins/description/","text":"Service description \u00b6 Once a service has been discovered, it is time to describe its capabilities. Capabilities in DYAMAND are modeled by a concept called State . A state describes a concept that the service provides data for or can control. A simple example of a state is a temperature, a device containing a temperature sensor can be modeled by a service containing a State of type Temperature. Indicating which states a particular service contains can be done by specifying the different states using State prototype , by claiming that the service follows a certain Service protoype or by using a combination of the first two possibilities. Service prototypes \u00b6 Services can optionally be created off of a service prototype. This means the created service will contain all mandatory states of the service prototype. Additional states can still be added if needed. The protocol variable in the snippet below is a DiscoveryProtocolProxy as described in Discoverying a new service . 1 2 3 4 5 6 7 8 9 10 11 12 13 ServiceBuilder < ExampleService > builder = this . protocol . newService ( id , ExampleService . class ); // add extra states optionally if ( * some condition * ) { builder . withState ( ExampleState . class ); } builder . build (( AsyncResult < Service > addService ) -> { if ( addService . succeeded ()) { // handle successfully adding the service // save the ServiceProxy from addService.result() for future reference } else { // handle failure to add service } }); State prototypes \u00b6 If services are not created based on a service prototype, states can be added based on state prototypes. From a client perspective, the only thing that changes is that the newService method is invoked without a service prototype. 1 2 3 4 5 6 7 8 this . protocol . newService ( id ). withState ( ExampleState . class ). and (). build (( AsyncResult < Service > addService ) -> { if ( addService . succeeded ()) { // handle successfully adding the service // save the ServiceProxy from addService.result() for future reference } else { // handle failure to add service } });","title":"Describing a device"},{"location":"plugins/description/#service-description","text":"Once a service has been discovered, it is time to describe its capabilities. Capabilities in DYAMAND are modeled by a concept called State . A state describes a concept that the service provides data for or can control. A simple example of a state is a temperature, a device containing a temperature sensor can be modeled by a service containing a State of type Temperature. Indicating which states a particular service contains can be done by specifying the different states using State prototype , by claiming that the service follows a certain Service protoype or by using a combination of the first two possibilities.","title":"Service description"},{"location":"plugins/description/#service-prototypes","text":"Services can optionally be created off of a service prototype. This means the created service will contain all mandatory states of the service prototype. Additional states can still be added if needed. The protocol variable in the snippet below is a DiscoveryProtocolProxy as described in Discoverying a new service . 1 2 3 4 5 6 7 8 9 10 11 12 13 ServiceBuilder < ExampleService > builder = this . protocol . newService ( id , ExampleService . class ); // add extra states optionally if ( * some condition * ) { builder . withState ( ExampleState . class ); } builder . build (( AsyncResult < Service > addService ) -> { if ( addService . succeeded ()) { // handle successfully adding the service // save the ServiceProxy from addService.result() for future reference } else { // handle failure to add service } });","title":"Service prototypes"},{"location":"plugins/description/#state-prototypes","text":"If services are not created based on a service prototype, states can be added based on state prototypes. From a client perspective, the only thing that changes is that the newService method is invoked without a service prototype. 1 2 3 4 5 6 7 8 this . protocol . newService ( id ). withState ( ExampleState . class ). and (). build (( AsyncResult < Service > addService ) -> { if ( addService . succeeded ()) { // handle successfully adding the service // save the ServiceProxy from addService.result() for future reference } else { // handle failure to add service } });","title":"State prototypes"},{"location":"plugins/discovery/","text":"Service discovery \u00b6 In the beginning, there was nothing. Discovery is the process of detecting new services in the environment and notifying applications of this fact. To be able to support this, there are two situations to take into account. First of all, when applications start, they want to be notified of the current situation. Second, if the application has already been started, it wants to be notified of any changes in the environment. This can be services coming online or leaving the environment. Protocols might or might not support searching the environment for services they support. Protocols also might or might not explicitly support discovering new services in the environment. Abstraction \u00b6 DYAMAND offers an abstraction towards applications that enables unified discovery of services regardless of the mechanism used by a particular protocol. To be able to do this, DYAMAND offers a way for plugins to indicate to DYAMAND when a new service has been detected. Similarly, it offers a way to indicate that a service is no longer active. This information allows DYAMAND to notify interested applications. Protocol registration \u00b6 The very first thing to do as a plugin that can discover services, is registering the protocol the plugin is responsible for. This can be done using the org.dyamand.discovery.Discovery service. 1 2 3 4 5 6 7 8 9 @Component ( immediate = true ) public final class NewProtocolPlugin { private final Discovery discovery ; @Activate public NewProtocolPlugin ( @Reference Discovery discovery ) { this . discovery = Objects . requireNonNull ( discovery ); } } Once you have acquired a reference to the Discovery service, you can build a org.dyamand.discovery.DiscoveryProtocolProxy like below. Be sure to save the DiscoveryProtocolProxy instance as it will be used to indicate to DYAMAND that you discovered a new service. The second argument of the withProtocol method is an IdentificationScheme . It is important to provide the correct identification scheme for a protocol since the generation of IDs is based on the identification scheme provided when building the DiscoveryProtocolProxy . There are four different identification schemes: IdentificationScheme.GLOBAL indicates that the identifier provided by the protocol uniquely identifies the discovered service globally IdentificationScheme.PROTOCOL indicates that the identifier provided by the protocol uniquely identifies the discovered service within the ecosystem of the protocol IdentificationScheme.INSTALLATION indicates that the identifier provided by the protocol is only unique on the specific installation that discovered the service, i.e. a service that is discovered on a different installation by the same protocol and with the same identifier does not (necessarily) refer to the same service IdentificationScheme.SESSION indicates that the identifier provided by the protocol is only unique for the current session, i.e. a service that is discovered later by the same protocol with the same identifier on the same installation does not (necessarily) refer to the same service 1 2 3 4 5 6 7 @Activate public void start () { this . discovery . withProtocol ( \"newProtocol\" , IdentificationScheme . PROTOCOL ). build (). onSuccess (( DiscoveryProtocolProxy createdProtocol ) -> { this . protocol = createdProtocol ; // start discovery process }); } Service discovery \u00b6 Whenever a new service has been detected, the plugin should notify this using the DiscoveryProtocolProxy instance. 1 2 3 4 5 6 7 8 9 10 // Just discovered a new service with identifier id at address address this . protocol . newService ( id ). atAddress ( address ) . build () . onSuccess (( final ServiceProxy < BasicService > proxy ) -> { // handle successfully adding the service // save the ServiceProxy from addService.result() for future reference }) . onFailure (( final Throwable t ) -> { // handle failure to add service }); As soon as the service is no longer online, the plugin should call dispose on the correct ServiceProxy instance. The correct ServiceProxy instance can either be saved when adding the service or it can be retrieved using the DiscoveryProtocolProxy#service(String) method. 1 2 // service with identifier id disappeared this . protocol . service ( id ). onSuccess ( AsyncDisposable :: dispose );","title":"Discovering a device"},{"location":"plugins/discovery/#service-discovery","text":"In the beginning, there was nothing. Discovery is the process of detecting new services in the environment and notifying applications of this fact. To be able to support this, there are two situations to take into account. First of all, when applications start, they want to be notified of the current situation. Second, if the application has already been started, it wants to be notified of any changes in the environment. This can be services coming online or leaving the environment. Protocols might or might not support searching the environment for services they support. Protocols also might or might not explicitly support discovering new services in the environment.","title":"Service discovery"},{"location":"plugins/discovery/#abstraction","text":"DYAMAND offers an abstraction towards applications that enables unified discovery of services regardless of the mechanism used by a particular protocol. To be able to do this, DYAMAND offers a way for plugins to indicate to DYAMAND when a new service has been detected. Similarly, it offers a way to indicate that a service is no longer active. This information allows DYAMAND to notify interested applications.","title":"Abstraction"},{"location":"plugins/discovery/#protocol-registration","text":"The very first thing to do as a plugin that can discover services, is registering the protocol the plugin is responsible for. This can be done using the org.dyamand.discovery.Discovery service. 1 2 3 4 5 6 7 8 9 @Component ( immediate = true ) public final class NewProtocolPlugin { private final Discovery discovery ; @Activate public NewProtocolPlugin ( @Reference Discovery discovery ) { this . discovery = Objects . requireNonNull ( discovery ); } } Once you have acquired a reference to the Discovery service, you can build a org.dyamand.discovery.DiscoveryProtocolProxy like below. Be sure to save the DiscoveryProtocolProxy instance as it will be used to indicate to DYAMAND that you discovered a new service. The second argument of the withProtocol method is an IdentificationScheme . It is important to provide the correct identification scheme for a protocol since the generation of IDs is based on the identification scheme provided when building the DiscoveryProtocolProxy . There are four different identification schemes: IdentificationScheme.GLOBAL indicates that the identifier provided by the protocol uniquely identifies the discovered service globally IdentificationScheme.PROTOCOL indicates that the identifier provided by the protocol uniquely identifies the discovered service within the ecosystem of the protocol IdentificationScheme.INSTALLATION indicates that the identifier provided by the protocol is only unique on the specific installation that discovered the service, i.e. a service that is discovered on a different installation by the same protocol and with the same identifier does not (necessarily) refer to the same service IdentificationScheme.SESSION indicates that the identifier provided by the protocol is only unique for the current session, i.e. a service that is discovered later by the same protocol with the same identifier on the same installation does not (necessarily) refer to the same service 1 2 3 4 5 6 7 @Activate public void start () { this . discovery . withProtocol ( \"newProtocol\" , IdentificationScheme . PROTOCOL ). build (). onSuccess (( DiscoveryProtocolProxy createdProtocol ) -> { this . protocol = createdProtocol ; // start discovery process }); }","title":"Protocol registration"},{"location":"plugins/discovery/#service-discovery_1","text":"Whenever a new service has been detected, the plugin should notify this using the DiscoveryProtocolProxy instance. 1 2 3 4 5 6 7 8 9 10 // Just discovered a new service with identifier id at address address this . protocol . newService ( id ). atAddress ( address ) . build () . onSuccess (( final ServiceProxy < BasicService > proxy ) -> { // handle successfully adding the service // save the ServiceProxy from addService.result() for future reference }) . onFailure (( final Throwable t ) -> { // handle failure to add service }); As soon as the service is no longer online, the plugin should call dispose on the correct ServiceProxy instance. The correct ServiceProxy instance can either be saved when adding the service or it can be retrieved using the DiscoveryProtocolProxy#service(String) method. 1 2 // service with identifier id disappeared this . protocol . service ( id ). onSuccess ( AsyncDisposable :: dispose );","title":"Service discovery"},{"location":"plugins/prototypes/","text":"Prototypes \u00b6 DYAMAND uses the Prototype design pattern to be able to describe services in a type-safe manner. Specifically, state prototypes and service prototypes are used to easily create services with particular capabilities. These prototypes are used together with the Builder design pattern to create whatever states or services need to be created. State prototypes \u00b6 State prototypes are blueprints for actual states in a service. Conceptually, there are three different types of states. Measurement states States that have values related to one or more units of measurement, e.g. Temperature has values that are related to Kelvin, degrees Celsius or degrees Fahrenheit. A special unit is the lack of a unit, also called a scalar or a quantity of dimension one. Discrete states States that have a finite collection of possible values, e.g. door open vs. closed. Dimensionless states States that do not have a dimension, just a value, e.g. a message that was sent by a technology State prototypes are both being used by general applications (generic states) as by technology-specific plugins (specific states). Translation plugins are responsible to translate specific states to generic states (TODO add link). A state prototype is an instance of State . org.dyamand.description.api provides a number of abstract classes to help you in implementing new states. Registering a state prototype can be done by getting a Description reference and registering it as in the example below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component ( immediate = true ) public final class ExampleTypePlugin { private final Description description ; @Activate public ExampleTypePlugin ( @Reference Description description ) { this . description = Objects . requireNonNull ( description ); } @Activate public void start () { this . description . newStatePrototype ( ExampleGenericState . class , ( AsyncResult < AsyncDisposable > newState ) -> { if ( newState . succeeded ()) { // save the AsyncDisposable to remove later } else { // handle failure to add state prototype } }); } } Service prototypes \u00b6 Apart from being able to register prototypes for a particular state, service prototypes allow for prototyping a complete service. A service prototype defines which states a service of that type can and should contain. The important methods for a service prototype are states() and mandatoryStates() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public final class ExampleService implements Service < ExampleService > { ... @Override public Class < ExampleService > type () { return ExampleService . class ; } @Override public Collection < State <?>> states () { return Arrays . asList ( exampleGenericStatePrototype , temperaturePrototype ); } @Override public Collection < State <?>> mandatoryStates () { return Collections . singleton ( temperaturePrototype ); } ... } Once such a service prototype is created, it can be registered similarly to how you register a state protoype. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component ( immediate = true ) public final class ExampleTypePlugin { private final Description description ; @Activate public ExampleTypePlugin ( @Reference Description description ) { this . description = Objects . requireNonNull ( description ); } @Activate public void start () { this . description . newServicePrototype ( ExampleService . class , ( AsyncResult < AsyncDisposable > newService ) -> { if ( newService . succeeded ()) { // save the AsyncDisposable to remove later } else { // handle failure to add service prototype } }); } } Once this has been done, technology plugins can use these prototypes to describe the services they discover.","title":"Adding new types"},{"location":"plugins/prototypes/#prototypes","text":"DYAMAND uses the Prototype design pattern to be able to describe services in a type-safe manner. Specifically, state prototypes and service prototypes are used to easily create services with particular capabilities. These prototypes are used together with the Builder design pattern to create whatever states or services need to be created.","title":"Prototypes"},{"location":"plugins/prototypes/#state-prototypes","text":"State prototypes are blueprints for actual states in a service. Conceptually, there are three different types of states. Measurement states States that have values related to one or more units of measurement, e.g. Temperature has values that are related to Kelvin, degrees Celsius or degrees Fahrenheit. A special unit is the lack of a unit, also called a scalar or a quantity of dimension one. Discrete states States that have a finite collection of possible values, e.g. door open vs. closed. Dimensionless states States that do not have a dimension, just a value, e.g. a message that was sent by a technology State prototypes are both being used by general applications (generic states) as by technology-specific plugins (specific states). Translation plugins are responsible to translate specific states to generic states (TODO add link). A state prototype is an instance of State . org.dyamand.description.api provides a number of abstract classes to help you in implementing new states. Registering a state prototype can be done by getting a Description reference and registering it as in the example below. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component ( immediate = true ) public final class ExampleTypePlugin { private final Description description ; @Activate public ExampleTypePlugin ( @Reference Description description ) { this . description = Objects . requireNonNull ( description ); } @Activate public void start () { this . description . newStatePrototype ( ExampleGenericState . class , ( AsyncResult < AsyncDisposable > newState ) -> { if ( newState . succeeded ()) { // save the AsyncDisposable to remove later } else { // handle failure to add state prototype } }); } }","title":"State prototypes"},{"location":"plugins/prototypes/#service-prototypes","text":"Apart from being able to register prototypes for a particular state, service prototypes allow for prototyping a complete service. A service prototype defines which states a service of that type can and should contain. The important methods for a service prototype are states() and mandatoryStates() . 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public final class ExampleService implements Service < ExampleService > { ... @Override public Class < ExampleService > type () { return ExampleService . class ; } @Override public Collection < State <?>> states () { return Arrays . asList ( exampleGenericStatePrototype , temperaturePrototype ); } @Override public Collection < State <?>> mandatoryStates () { return Collections . singleton ( temperaturePrototype ); } ... } Once such a service prototype is created, it can be registered similarly to how you register a state protoype. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Component ( immediate = true ) public final class ExampleTypePlugin { private final Description description ; @Activate public ExampleTypePlugin ( @Reference Description description ) { this . description = Objects . requireNonNull ( description ); } @Activate public void start () { this . description . newServicePrototype ( ExampleService . class , ( AsyncResult < AsyncDisposable > newService ) -> { if ( newService . succeeded ()) { // save the AsyncDisposable to remove later } else { // handle failure to add service prototype } }); } } Once this has been done, technology plugins can use these prototypes to describe the services they discover.","title":"Service prototypes"},{"location":"plugins/state_changes_with_translations/","text":"","title":"Detecting state changes with translations"},{"location":"plugins/state_changes_without_translations/","text":"","title":"Detecting state changes without translations"},{"location":"plugins/structure/","text":"How to structure technology support in DYAMAND \u00b6 Technology support is a multi-faceted problem. DYAMAND offers a structure to break down this support into manageable pieces. To be able to do this, some best practices should be taken into account. Repository layout \u00b6 In general, all projects related to a particular technology should reside in one git repository named dyamand- technologyname 1 . In this repository different projects that together offer the technology support for this technology are put together. Technology API \u00b6 There should be a project that defines the DYAMAND concepts used for this technology, so it can be used by any other project, it should be named org.dyamand. technologyname .api 1 . It should include a component that implements an interface named org.dyamand. technologyname . TechnologyName 1 2 . This component should make sure all necessary concepts (State prototypes, service prototypes, etc.) are registered when this component is activated, to indicate that everything is ready for other plugins to start doing their work. the technology name should be all lower case in this instance \u21a9 \u21a9 \u21a9 the technology name should be camel case in this instance \u21a9","title":"Structure"},{"location":"plugins/structure/#how-to-structure-technology-support-in-dyamand","text":"Technology support is a multi-faceted problem. DYAMAND offers a structure to break down this support into manageable pieces. To be able to do this, some best practices should be taken into account.","title":"How to structure technology support in DYAMAND"},{"location":"plugins/structure/#repository-layout","text":"In general, all projects related to a particular technology should reside in one git repository named dyamand- technologyname 1 . In this repository different projects that together offer the technology support for this technology are put together.","title":"Repository layout"},{"location":"plugins/structure/#technology-api","text":"There should be a project that defines the DYAMAND concepts used for this technology, so it can be used by any other project, it should be named org.dyamand. technologyname .api 1 . It should include a component that implements an interface named org.dyamand. technologyname . TechnologyName 1 2 . This component should make sure all necessary concepts (State prototypes, service prototypes, etc.) are registered when this component is activated, to indicate that everything is ready for other plugins to start doing their work. the technology name should be all lower case in this instance \u21a9 \u21a9 \u21a9 the technology name should be camel case in this instance \u21a9","title":"Technology API"},{"location":"plugins/tests/","text":"Tests for plugins \u00b6 Plugins can use these generic tests to test functionality they provide. To be able to use these tests, simply let your test class implement WithPluginTests . Discovery \u00b6 The test method testDiscovery provides a way to test discovery implemented by a plugin. A Consumer<Discovery> that triggers the discovery of a single service has to be provided together with the type of service that should have been discovered and its ID. State changes \u00b6 The test method testStateChange provides a way to test whether or not a plugin successfully implements data retrieval. A Consumer<Discovery> that triggers discovery of a single service together with 1 changing state should be provided. Additionally, the type of state that should have been changed and optionally its value should be provided. Translators \u00b6 Tests for state prototypes \u00b6 State prototypes have an important role in abstracting the functionality of devices towards applications, this section specifies which tests are relevant for state prototypes and how to take advantage of them. All state prototypes can take advantage of the tests below. This can be done by extending AbstractStatePrototypeTest . 0.0.0 When creating a state with a certain id and value from a state prototype, the created state should be of the same type as the state prototype, have the provided id and its value should be equal to the provided value Additionally, measurement states can taken advantage of the tests below. This can be done by extending AbstractMeasurementStatePrototypeTest . 0.1.0 When a measurement state is created with a certain value and unit, creating a new state based on any other unit should result in the same value in the original unit","title":"Tests"},{"location":"plugins/tests/#tests-for-plugins","text":"Plugins can use these generic tests to test functionality they provide. To be able to use these tests, simply let your test class implement WithPluginTests .","title":"Tests for plugins"},{"location":"plugins/tests/#discovery","text":"The test method testDiscovery provides a way to test discovery implemented by a plugin. A Consumer<Discovery> that triggers the discovery of a single service has to be provided together with the type of service that should have been discovered and its ID.","title":"Discovery"},{"location":"plugins/tests/#state-changes","text":"The test method testStateChange provides a way to test whether or not a plugin successfully implements data retrieval. A Consumer<Discovery> that triggers discovery of a single service together with 1 changing state should be provided. Additionally, the type of state that should have been changed and optionally its value should be provided.","title":"State changes"},{"location":"plugins/tests/#translators","text":"","title":"Translators"},{"location":"plugins/tests/#tests-for-state-prototypes","text":"State prototypes have an important role in abstracting the functionality of devices towards applications, this section specifies which tests are relevant for state prototypes and how to take advantage of them. All state prototypes can take advantage of the tests below. This can be done by extending AbstractStatePrototypeTest . 0.0.0 When creating a state with a certain id and value from a state prototype, the created state should be of the same type as the state prototype, have the provided id and its value should be equal to the provided value Additionally, measurement states can taken advantage of the tests below. This can be done by extending AbstractMeasurementStatePrototypeTest . 0.1.0 When a measurement state is created with a certain value and unit, creating a new state based on any other unit should result in the same value in the original unit","title":"Tests for state prototypes"},{"location":"styleguides/logging/","text":"Using loggers \u00b6 In DYAMAND plugins/components, the OSGi logger and loggerFactory interfaces are used. A logger for your component can be obtained through reference of the LoggerFactory, by using the following syntax in the constructor of the class: 1 2 3 4 5 6 7 8 @Component public final class foo @Activate public foo ( @Reference ( service = LoggerFactory . class ) final Logger logger ){ // ... logger . info ( \"Foo started!\" ) } } The obtained logger will use the component's PID in its log statements, therefore it is advised to let each component obtain its own logger. The OGSi Logger interface provides 2 main ways to log messages: 1. Log message directly: logger.info(\"The statement will always be evaluated\"); Log message with lambda: logger.info((Logger l) -> l.info(\"This statement will only be evaluated if the log level is set at or below 'INFO'\")); The second approach is generally recommended, as it is beneficial for performance on higher log levels. For simple log statements, the first approach can still be used. To add information to your log statements, use curly braces. Pairs of curly braces will be replaced, in order, by the additional parameters you hand to the log statement. 1 logger . info ( \"Use {} if you want to put information in your {}.\" , \"curly braces\" , \"log statements\" ); toString() is automatically called on objects you pass through to the logger. 1 2 Map < String , String > someMap = new HashMap <> (); logger . info ( \"Content of someMap: {}\" , someMap ); If you are handling exceptions, you can add stacktraces of throwables to your log statements by adding the throwable as the last parameter. 1 2 3 4 5 try { // Throw something } catch ( Throwable t ){ logger . error ( \"That did not go as expected\" , t ); } You can combine this functionality with the use of curly braces. 1 2 3 4 5 6 Object someObject ; try { // Throw something } catch ( Throwable t ){ logger . error ( \"Failed to process {} correctly\" , someObject , t ); } Your log statement should have the following parameters, in order: * the message itself * a number of objects or function calls equal to the number of curly brace pairs in your message * (optional) a Throwable in case you want to append its stacktrace Changing the log level \u00b6 If you are using the gogo shell, you can change the global log level with the command logconfig [LEVEL] . To change the log level of a specific logger, mention the PID: logconfig some.random.pid [LEVEL] The log level can also be set through the use of an environment variable. Set DYAMAND_DEFAULT_LOG_LEVEL to any supported log level to change the default configuration. Note that using gogo's logconfig command will override this setting. Supported log levels \u00b6 Level Usage Examples TRACE Display most minute details about operations and data going through the system. Full content of data structures Step-by-step data flow through function DEBUG Provide detailed information about data and actions being taken, to make it easier to detect what is going wrong. Important fields from used data structures (possible abbreviated or filtered) Reporting of data flow through function INFO Give a coarse-grained indication of what the system is doing. Start and stop of services Important functions get called WARN Log information about actions that differ from the expected procedure. Missing expected but non-critical data Abnormal values indicating unusual behaviour Semi-expected invalid values which map to valid values, e.g. integer sent as string Iffy connections that have to be restarted in the middle of an operation ERROR Log information about actions that could not be handled at all, or could only be partially completed Missing critical data Unexpected values Missing required connection AUDIT Audit statements will always be printed, regardless of configured log level. Use audit statements to track important user activities and to detect unauthorized access. See the auditing subsection for more info. User login attempt Change of important data value Audit logging \u00b6 Audit log statements are different from the other log levels in that their main purpose is not diagnosing, but tracking changes. To allow easy processing of audit statements, they should be logged in the form of a JSON-object containing key-value pairs. Recommended fields: user : JSON Object with nested key-values: username : String representing user initiating action groups : JSON Array with groups the user belonged to at moment of logging In the case of a system generated action, username should be \"system\" and groups should be empty (or an appropriate list of groups if applicable) verb : String indicating action to be taken on resource. This should be a simple keyword, e.g. get/list/add/delete/... objectRef : resource : String indicating on what type of resource the action was performed. This is a high level indicator, and should not refer to specific instances. name : name of the resource on which the action was taken annotations : JSON object containing extra information about the action, e.g. decision: allow|deny : whether the action was allowed to go through or not reason: * : details about why the action was (dis)allowed NOTE: while it is strongly recommended to provide as many of the recommended fields as possible, some components might be lacking information to completely fill out all fields. In such cases, multiple components should each log their part of the audit statement. By following the audit log, one should still be able to obtain all required info. NOTE: Extra fields may be added as needed. While care should be taken to follow the recommended field layout as much as possible, any extra available information should be logged through additional fields. E.g. in some cases, the object might also belong to specific groups. Or an object might not possess a unique name, but consist of unique subelements. Implemented audit statements \u00b6 User permissions \u00b6 Permissions Manager (No initiator info) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"verb\" : \"add\" , \"objectRef\" :{ \"resource\" : \"permission\" , \"name\" : \"p\" , \"subject\" : \"user:testuser1@dyamand.be\" , \"object\" : \"profile:testprofile1\" , \"permission\" : \"PERMISSION_TEST\" }, \"annotations\" :{ \"decision\" : \"allow\" , \"result\" : \"added\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"verb\" : \"delete\" , \"objectRef\" :{ \"resource\" : \"grouping\" , \"name\" : \"g3\" , \"child\" : \"PERMISSION_TEST_01\" , \"parent\" : \"PERMISSION_TEST_02\" }, \"annotations\" :{ \"decision\" : \"allow\" , \"result\" : \"not present\" } } User Service (Has initatior info) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"user\" :{ \"username\" : \"system\" , \"groups\" :[ ] }, \"objectRef\" :{ \"resource\" : \"permission\" , \"object\" : \"system\" , \"subject\" : \"user:testuser1@dyamand.be\" , \"permission\" : \"CREATE_ORGANIZATION\" }, \"verb\" : \"add\" , \"annotations\" :{ } } DYAMAND audit statement proposals \u00b6 Detecting a new installation The DYAMAND backend receives an installation event from a new installation. As the system is allowed to perform all actions, no decision annotation is added. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"user\" : { \"username\" : \"system\" , \"groups\" :[] }, { \"objectRef\" : { \"resource\" : \"installation\" , \"name\" : \"COT-GW-001\" }, \"verb\" : \"add\" , \"annotations\" :{} } Removing an installation from a project User is assigned to project, therefore removing an installation from the project is allowed. The installation itself is still present in the system and is potentially linked to other projects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"user\" : { \"username\" : \"john-doe\" , \"groups\" :[ \"cot:internet-of-water\" , \"system:authenticated\" ] }, { \"objectRef\" : { \"resource\" : \"installationRef\" , \"name\" : \"COT-GW-001\" , \"project\" : \"cot:internet-of-water\" }, \"verb\" : \"delete\" , \"annotations\" :{ \"authorization.dyamand/decision\" : \"allow\" } } Removing an installation from the system completely A user attempts to remove an installation from the system, as this user is not a DYAMAND admin, the action is denied. The user is only able to configure project specific settings of the installation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"user\" : { \"username\" : \"john-doe\" , \"groups\" :[ \"cot:internet-of-water\" , \"system:authenticated\" ] }, { \"objectRef\" : { \"resource\" : \"installation\" , \"name\" : \"COT-GW-001\" }, \"verb\" : \"delete\" , \"annotations\" :{ \"authorization.dyamand/decision\" : \"deny\" } }","title":"Logging"},{"location":"styleguides/logging/#using-loggers","text":"In DYAMAND plugins/components, the OSGi logger and loggerFactory interfaces are used. A logger for your component can be obtained through reference of the LoggerFactory, by using the following syntax in the constructor of the class: 1 2 3 4 5 6 7 8 @Component public final class foo @Activate public foo ( @Reference ( service = LoggerFactory . class ) final Logger logger ){ // ... logger . info ( \"Foo started!\" ) } } The obtained logger will use the component's PID in its log statements, therefore it is advised to let each component obtain its own logger. The OGSi Logger interface provides 2 main ways to log messages: 1. Log message directly: logger.info(\"The statement will always be evaluated\"); Log message with lambda: logger.info((Logger l) -> l.info(\"This statement will only be evaluated if the log level is set at or below 'INFO'\")); The second approach is generally recommended, as it is beneficial for performance on higher log levels. For simple log statements, the first approach can still be used. To add information to your log statements, use curly braces. Pairs of curly braces will be replaced, in order, by the additional parameters you hand to the log statement. 1 logger . info ( \"Use {} if you want to put information in your {}.\" , \"curly braces\" , \"log statements\" ); toString() is automatically called on objects you pass through to the logger. 1 2 Map < String , String > someMap = new HashMap <> (); logger . info ( \"Content of someMap: {}\" , someMap ); If you are handling exceptions, you can add stacktraces of throwables to your log statements by adding the throwable as the last parameter. 1 2 3 4 5 try { // Throw something } catch ( Throwable t ){ logger . error ( \"That did not go as expected\" , t ); } You can combine this functionality with the use of curly braces. 1 2 3 4 5 6 Object someObject ; try { // Throw something } catch ( Throwable t ){ logger . error ( \"Failed to process {} correctly\" , someObject , t ); } Your log statement should have the following parameters, in order: * the message itself * a number of objects or function calls equal to the number of curly brace pairs in your message * (optional) a Throwable in case you want to append its stacktrace","title":"Using loggers"},{"location":"styleguides/logging/#changing-the-log-level","text":"If you are using the gogo shell, you can change the global log level with the command logconfig [LEVEL] . To change the log level of a specific logger, mention the PID: logconfig some.random.pid [LEVEL] The log level can also be set through the use of an environment variable. Set DYAMAND_DEFAULT_LOG_LEVEL to any supported log level to change the default configuration. Note that using gogo's logconfig command will override this setting.","title":"Changing the log level"},{"location":"styleguides/logging/#supported-log-levels","text":"Level Usage Examples TRACE Display most minute details about operations and data going through the system. Full content of data structures Step-by-step data flow through function DEBUG Provide detailed information about data and actions being taken, to make it easier to detect what is going wrong. Important fields from used data structures (possible abbreviated or filtered) Reporting of data flow through function INFO Give a coarse-grained indication of what the system is doing. Start and stop of services Important functions get called WARN Log information about actions that differ from the expected procedure. Missing expected but non-critical data Abnormal values indicating unusual behaviour Semi-expected invalid values which map to valid values, e.g. integer sent as string Iffy connections that have to be restarted in the middle of an operation ERROR Log information about actions that could not be handled at all, or could only be partially completed Missing critical data Unexpected values Missing required connection AUDIT Audit statements will always be printed, regardless of configured log level. Use audit statements to track important user activities and to detect unauthorized access. See the auditing subsection for more info. User login attempt Change of important data value","title":"Supported log levels"},{"location":"styleguides/logging/#audit-logging","text":"Audit log statements are different from the other log levels in that their main purpose is not diagnosing, but tracking changes. To allow easy processing of audit statements, they should be logged in the form of a JSON-object containing key-value pairs. Recommended fields: user : JSON Object with nested key-values: username : String representing user initiating action groups : JSON Array with groups the user belonged to at moment of logging In the case of a system generated action, username should be \"system\" and groups should be empty (or an appropriate list of groups if applicable) verb : String indicating action to be taken on resource. This should be a simple keyword, e.g. get/list/add/delete/... objectRef : resource : String indicating on what type of resource the action was performed. This is a high level indicator, and should not refer to specific instances. name : name of the resource on which the action was taken annotations : JSON object containing extra information about the action, e.g. decision: allow|deny : whether the action was allowed to go through or not reason: * : details about why the action was (dis)allowed NOTE: while it is strongly recommended to provide as many of the recommended fields as possible, some components might be lacking information to completely fill out all fields. In such cases, multiple components should each log their part of the audit statement. By following the audit log, one should still be able to obtain all required info. NOTE: Extra fields may be added as needed. While care should be taken to follow the recommended field layout as much as possible, any extra available information should be logged through additional fields. E.g. in some cases, the object might also belong to specific groups. Or an object might not possess a unique name, but consist of unique subelements.","title":"Audit logging"},{"location":"styleguides/logging/#implemented-audit-statements","text":"","title":"Implemented audit statements"},{"location":"styleguides/logging/#user-permissions","text":"Permissions Manager (No initiator info) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \"verb\" : \"add\" , \"objectRef\" :{ \"resource\" : \"permission\" , \"name\" : \"p\" , \"subject\" : \"user:testuser1@dyamand.be\" , \"object\" : \"profile:testprofile1\" , \"permission\" : \"PERMISSION_TEST\" }, \"annotations\" :{ \"decision\" : \"allow\" , \"result\" : \"added\" } } 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"verb\" : \"delete\" , \"objectRef\" :{ \"resource\" : \"grouping\" , \"name\" : \"g3\" , \"child\" : \"PERMISSION_TEST_01\" , \"parent\" : \"PERMISSION_TEST_02\" }, \"annotations\" :{ \"decision\" : \"allow\" , \"result\" : \"not present\" } } User Service (Has initatior info) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"user\" :{ \"username\" : \"system\" , \"groups\" :[ ] }, \"objectRef\" :{ \"resource\" : \"permission\" , \"object\" : \"system\" , \"subject\" : \"user:testuser1@dyamand.be\" , \"permission\" : \"CREATE_ORGANIZATION\" }, \"verb\" : \"add\" , \"annotations\" :{ } }","title":"User permissions"},{"location":"styleguides/logging/#dyamand-audit-statement-proposals","text":"Detecting a new installation The DYAMAND backend receives an installation event from a new installation. As the system is allowed to perform all actions, no decision annotation is added. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \"user\" : { \"username\" : \"system\" , \"groups\" :[] }, { \"objectRef\" : { \"resource\" : \"installation\" , \"name\" : \"COT-GW-001\" }, \"verb\" : \"add\" , \"annotations\" :{} } Removing an installation from a project User is assigned to project, therefore removing an installation from the project is allowed. The installation itself is still present in the system and is potentially linked to other projects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \"user\" : { \"username\" : \"john-doe\" , \"groups\" :[ \"cot:internet-of-water\" , \"system:authenticated\" ] }, { \"objectRef\" : { \"resource\" : \"installationRef\" , \"name\" : \"COT-GW-001\" , \"project\" : \"cot:internet-of-water\" }, \"verb\" : \"delete\" , \"annotations\" :{ \"authorization.dyamand/decision\" : \"allow\" } } Removing an installation from the system completely A user attempts to remove an installation from the system, as this user is not a DYAMAND admin, the action is denied. The user is only able to configure project specific settings of the installation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 { \"user\" : { \"username\" : \"john-doe\" , \"groups\" :[ \"cot:internet-of-water\" , \"system:authenticated\" ] }, { \"objectRef\" : { \"resource\" : \"installation\" , \"name\" : \"COT-GW-001\" }, \"verb\" : \"delete\" , \"annotations\" :{ \"authorization.dyamand/decision\" : \"deny\" } }","title":"DYAMAND audit statement proposals"},{"location":"technologies/bluetooth/","text":"DYAMAND-Bluetooth plugin \u00b6 Context \u00b6 Bluetooth is a short range wireless technology standard using UHF radio waves in the ISM band. Bluetooth Low Energy (BLE) has been part of the standard since version 4.0. This plug-in makes no distinction between the two. GATT \u00b6 The DYAMAND Bluetooth plugin is capable of discovering Bluetooth (and BLE) devices. Data acquisition is done through the device's provided GATT attributes. A device may serve as a GATT server that hosts GATT attributes. GATT servers organize data in services, which hold characteristics. Some services have been standardized so the service determines which characteristics should be present. Standardized GATT profiles determine which services should be present. Attribute UUIDs determine whether the service / characteristic is standardized or not (note that the UUID determines WHAT the attribute is but does not serve as an ID for which attribute it is). Attributes have a 16 byte UUID. In case of standardized attributes this UUID takes the form of a 16 or 32 bit UUID which is extended by the default Bluetooth Base UUID. Specifically: xxxxxxxx-0000-1000-8000-00805F9B34FB Where the xxxxxxxx is replaced by the standardized 16 or 32 bit (including leading 0s) UUID. The full list of standardized 16 UUID numbers can be found here For instance the following UUID specifies a PLX Spot-Check Measurement: 00002a5e-0000-1000-8000-00805F9B34FB This characteristic is part of the pulse oximeter service: 00001822-0000-1000-8000-00805F9B34FB Services and characteristics are described in xml format BlueZ over DBus \u00b6 This plug-in uses BlueZ over DBus for all discovery and data access. DBus is an inter-process communication and remote procedure call mechanism and BlueZ is a Bluetooth library registered on DBus. Discovery \u00b6 GATT services and characteristics can be discovered when a device is connected. When starting from a 'clean slate' scenario (i.e. no devices, services or characteristics are known) an adapter needs to be powered on and a device needs to be discovered. Once discovered the plug-in needs to connect to it. Its services can then be resolved. A device has a flag (ServicesResolved) that indicates if the device's services have been resolved. This way it is possible to distinguish between a device with unresolved services and a device without services. The BlueZ ObjectManager keeps track of all found devices, services, characteristics etc and is used to do discovery of new devices, services and characteristics. It also knows when devices, services and characteristics are removed. No heartbeat mechanism is used and services and characteristics persist in BlueZ even when the device has disconnected. However, you are guaranteed that the services and characteristics are unchanged when the device is reconnected (even if it power cycled). Identification \u00b6 Bluetooth devices are (globally) uniquely identified through their MAC address (format= xx:xx:xx:xx:xx:xx). The device services and characteristics are (per device) uniquely identified through their handle, which is a 16-bit identifier. Therefore the combination of the device MAC address and service handle uniquely identifies a service. Data model \u00b6 DYAMAND models GATT services as DYAMAND services and groups them by Bluetooth device. The GATT characteristics are the states of the DYAMAND services. The services are identified by an identifier generated as '{mac_address}/service{service_handle}' (e.g. '00:1C:05:FE:44:6B/service0006'). Characteristics are identified through their characteristic handle (e.g. 'char0007'). Control \u00b6 Health information \u00b6 Available libraries \u00b6 BlueZ \u00b6 BlueZ is a Bluetooth stack for Linux kernel-based family of operating systems. Its goal is to program an implementation of the Bluetooth wireless standards specifications for Linux. As of 2006, the BlueZ stack supports all core Bluetooth protocols and layers. It was initially developed by Qualcomm, and is available for Linux kernel versions 2.4.6 and up. In addition to the basic stack, the bluez-utils and bluez-firmware packages contain low level utilities such as dfutool which can interrogate the Bluetooth adapter chipset to determine whether its firmware can be upgraded. hidd is the Bluetooth human interface device (HID) daemon. BlueZ is licensed under the GNU General Public License (GPL), but reported to be on its way toward switching to the GNU Lesser General Public License (LGPL). Visualization \u00b6 The d-feet program (available through aptitude) allows users to visualize all d-bus objects. Searching for 'bluez' will show all discovered bluez objects and allow users to read data and call methods.","title":"Bluetooth"},{"location":"technologies/bluetooth/#dyamand-bluetooth-plugin","text":"","title":"DYAMAND-Bluetooth plugin"},{"location":"technologies/bluetooth/#context","text":"Bluetooth is a short range wireless technology standard using UHF radio waves in the ISM band. Bluetooth Low Energy (BLE) has been part of the standard since version 4.0. This plug-in makes no distinction between the two.","title":"Context"},{"location":"technologies/bluetooth/#gatt","text":"The DYAMAND Bluetooth plugin is capable of discovering Bluetooth (and BLE) devices. Data acquisition is done through the device's provided GATT attributes. A device may serve as a GATT server that hosts GATT attributes. GATT servers organize data in services, which hold characteristics. Some services have been standardized so the service determines which characteristics should be present. Standardized GATT profiles determine which services should be present. Attribute UUIDs determine whether the service / characteristic is standardized or not (note that the UUID determines WHAT the attribute is but does not serve as an ID for which attribute it is). Attributes have a 16 byte UUID. In case of standardized attributes this UUID takes the form of a 16 or 32 bit UUID which is extended by the default Bluetooth Base UUID. Specifically: xxxxxxxx-0000-1000-8000-00805F9B34FB Where the xxxxxxxx is replaced by the standardized 16 or 32 bit (including leading 0s) UUID. The full list of standardized 16 UUID numbers can be found here For instance the following UUID specifies a PLX Spot-Check Measurement: 00002a5e-0000-1000-8000-00805F9B34FB This characteristic is part of the pulse oximeter service: 00001822-0000-1000-8000-00805F9B34FB Services and characteristics are described in xml format","title":"GATT"},{"location":"technologies/bluetooth/#bluez-over-dbus","text":"This plug-in uses BlueZ over DBus for all discovery and data access. DBus is an inter-process communication and remote procedure call mechanism and BlueZ is a Bluetooth library registered on DBus.","title":"BlueZ over DBus"},{"location":"technologies/bluetooth/#discovery","text":"GATT services and characteristics can be discovered when a device is connected. When starting from a 'clean slate' scenario (i.e. no devices, services or characteristics are known) an adapter needs to be powered on and a device needs to be discovered. Once discovered the plug-in needs to connect to it. Its services can then be resolved. A device has a flag (ServicesResolved) that indicates if the device's services have been resolved. This way it is possible to distinguish between a device with unresolved services and a device without services. The BlueZ ObjectManager keeps track of all found devices, services, characteristics etc and is used to do discovery of new devices, services and characteristics. It also knows when devices, services and characteristics are removed. No heartbeat mechanism is used and services and characteristics persist in BlueZ even when the device has disconnected. However, you are guaranteed that the services and characteristics are unchanged when the device is reconnected (even if it power cycled).","title":"Discovery"},{"location":"technologies/bluetooth/#identification","text":"Bluetooth devices are (globally) uniquely identified through their MAC address (format= xx:xx:xx:xx:xx:xx). The device services and characteristics are (per device) uniquely identified through their handle, which is a 16-bit identifier. Therefore the combination of the device MAC address and service handle uniquely identifies a service.","title":"Identification"},{"location":"technologies/bluetooth/#data-model","text":"DYAMAND models GATT services as DYAMAND services and groups them by Bluetooth device. The GATT characteristics are the states of the DYAMAND services. The services are identified by an identifier generated as '{mac_address}/service{service_handle}' (e.g. '00:1C:05:FE:44:6B/service0006'). Characteristics are identified through their characteristic handle (e.g. 'char0007').","title":"Data model"},{"location":"technologies/bluetooth/#control","text":"","title":"Control"},{"location":"technologies/bluetooth/#health-information","text":"","title":"Health information"},{"location":"technologies/bluetooth/#available-libraries","text":"","title":"Available libraries"},{"location":"technologies/bluetooth/#bluez","text":"BlueZ is a Bluetooth stack for Linux kernel-based family of operating systems. Its goal is to program an implementation of the Bluetooth wireless standards specifications for Linux. As of 2006, the BlueZ stack supports all core Bluetooth protocols and layers. It was initially developed by Qualcomm, and is available for Linux kernel versions 2.4.6 and up. In addition to the basic stack, the bluez-utils and bluez-firmware packages contain low level utilities such as dfutool which can interrogate the Bluetooth adapter chipset to determine whether its firmware can be upgraded. hidd is the Bluetooth human interface device (HID) daemon. BlueZ is licensed under the GNU General Public License (GPL), but reported to be on its way toward switching to the GNU Lesser General Public License (LGPL).","title":"BlueZ"},{"location":"technologies/bluetooth/#visualization","text":"The d-feet program (available through aptitude) allows users to visualize all d-bus objects. Searching for 'bluez' will show all discovered bluez objects and allow users to read data and call methods.","title":"Visualization"},{"location":"technologies/octa/","text":"OCTA protocol \u00b6 OCTA Connect is a hardware platform for low-power and wireless projects. OCTA is part of the IDLab IoT platform together with DYAMAND. To communicate with DYAMAND, the OCTA protocol is being designed. Tests for OCTA protocol \u00b6 octa.0.0 Any valid OCTA message without payload should be parseable octa.0.1 All added headers should be available in the parsed message","title":"OCTA"},{"location":"technologies/octa/#octa-protocol","text":"OCTA Connect is a hardware platform for low-power and wireless projects. OCTA is part of the IDLab IoT platform together with DYAMAND. To communicate with DYAMAND, the OCTA protocol is being designed.","title":"OCTA protocol"},{"location":"technologies/octa/#tests-for-octa-protocol","text":"octa.0.0 Any valid OCTA message without payload should be parseable octa.0.1 All added headers should be available in the parsed message","title":"Tests for OCTA protocol"},{"location":"technologies/template/","text":"Template for technologies supported by DYAMAND \u00b6 Context \u00b6 Explain the technology. Discovery \u00b6 Is discovery supported? Heartbeat mechanism? Alive/byebye message? How are devices identified -> explain IdentificationScheme Data model \u00b6 Control \u00b6 Health information \u00b6 Available libraries \u00b6","title":"Template for new technologies"},{"location":"technologies/template/#template-for-technologies-supported-by-dyamand","text":"","title":"Template for technologies supported by DYAMAND"},{"location":"technologies/template/#context","text":"Explain the technology.","title":"Context"},{"location":"technologies/template/#discovery","text":"Is discovery supported? Heartbeat mechanism? Alive/byebye message? How are devices identified -> explain IdentificationScheme","title":"Discovery"},{"location":"technologies/template/#data-model","text":"","title":"Data model"},{"location":"technologies/template/#control","text":"","title":"Control"},{"location":"technologies/template/#health-information","text":"","title":"Health information"},{"location":"technologies/template/#available-libraries","text":"","title":"Available libraries"}]}